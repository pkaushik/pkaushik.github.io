<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Webapps | Pallavi Anderson]]></title>
  <link href="http://asynchrotron.com/blog/categories/webapps/atom.xml" rel="self"/>
  <link href="http://asynchrotron.com/"/>
  <updated>2013-12-29T00:01:50-06:00</updated>
  <id>http://asynchrotron.com/</id>
  <author>
    <name><![CDATA[Pallavi Anderson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Realtime Maps With Meteor and Leaflet - Part Two]]></title>
    <link href="http://asynchrotron.com/blog/2013/12/28/realtime-maps-with-meteor-and-leaflet-part-2/"/>
    <updated>2013-12-28T17:53:06-06:00</updated>
    <id>http://asynchrotron.com/blog/2013/12/28/realtime-maps-with-meteor-and-leaflet-part-2</id>
    <content type="html"><![CDATA[<p><span class='caption-wrapper left'><img class='caption' src='/images/custom/updated-parties.png' width='' height='' title='this is a Leaflet map with DivIcon markers'><span class='caption-text'>this is a Leaflet map with DivIcon markers</span></span></p>

<h3>Recap</h3>


<p>In the <a href="/blog/2013/12/27/realtime-maps-with-meteor-and-leaflet/">last post</a>, we initialized a Leaflet map to work with <a href="http://stamen.com/">Stamen Design</a>&rsquo;s <a href="http://maps.stamen.com/toner/#12/37.7706/-122.3782">toner themed map tiles</a> and <a href="http://getbootstrap.com/2.3.2/scaffolding.html#responsive">Bootstrap&rsquo;s responsive layout</a>. We then set up a double-click event handler to gather additional details about the proposed new party, and we hooked up the dialog&rsquo;s save button to pass those details to a <code>Meteor.methods()</code> call to save the party into a server-side mongo collection. Finally, we hooked up a <code>cursor.observe()</code> <code>added()</code> callback to a query on the client-side minimongo collection and set up the callback to automatically add a circular <code>DivIcon</code> marker at the specified coordinates.</p>

<h3>Updating Party Details in the Database</h3>


<p>A party document saved to mongo looks something like this:
``` js
{
  _id: &ldquo;22dQwpajD64LCv4QW&rdquo;,
  title: &ldquo;1871&rdquo;,
  description: &ldquo;Party like it&rsquo;s 1871!&rdquo;,
  latlng: {</p>

<pre><code>lat: 41.88298161317542,
lng:  -87.63811111450194
</code></pre>

<p>  },
  public: false,
  owner: &ldquo;52xdsNjprquesL2tQ&rdquo;,
  invited: [&ldquo;52xdsNjprquesL2tQ&rdquo;, &ldquo;ci7bzkJCpH9R7HCZK&rdquo;, &ldquo;5qhRdKFcsmPnxZKBr&rdquo;]
  rsvps: [</p>

<pre><code>{
  rsvp: "yes",
  user: "52xdsNjprquesL2tQ"
},
{
  rsvp: "maybe",
  user: "ci7bzkJCpH9R7HCZK"
}
</code></pre>

<p>  ]
}
<code>
Each party contains an array of RSVP objects, which must be updated when any user updates their RSVP to the party. In addition, private parties contain a set of invited userIds. So</code>rsvps<code>and</code>invited``` are the two mutable attributes of a party; the owner, title, description, coordinates or public/private setting cannot be updated as per the original example.</p>

<p>In addition, a party&rsquo;s owner can delete the party if no user is RSVPd as Yes (Maybes don&rsquo;t count).</p>

<p>The code to update and delete parties in the server-side mongo collection is virtually unchanged from the original. The <code>invite()</code> and <code>rsvp()</code> template event handlers are hooked to <code>Meteor.methods()</code> calls that perform the necessary checks before updating the mongo collection on the server. As usual, Meteor, behind the scenes, updates the client-side minimongo collection as soon as the server collection is updated.</p>

<h3>Updating and Removing Map Markers in Realtime</h3>


<p>Now it&rsquo;s time to add in the <code>cursor.observe()</code> <code>changed()</code> callback to update the party&rsquo;s icon, and <code>removed()</code>  callback to delete the marker from the map and from the local <code>markers</code> hash.</p>

<p>``` js
var map, markers = {};</p>

<p>Template.map.created = function() {
  Parties.find({}).observe({</p>

<pre><code>added: function(party) {/* see previous post */},
changed: function(party) {
  var marker = markers[party._id];
  if (marker) marker.setIcon(createIcon(party));
},
removed: function(party) {
  var marker = markers[party._id];
  if (map.hasLayer(marker)) {
    map.removeLayer(marker);
    delete markers[party._id];
  }
}
</code></pre>

<p>  });
}
```</p>

<h3>Using a Halo Marker to Indicate Which Party Is Selected</h3>


<p><span class='caption-wrapper right'><img class='caption' src='/images/custom/selected-party.png' width='' height='' title='a selected party'><span class='caption-text'>a selected party</span></span></p>

<p>Up to this point, there&rsquo;s been no visual indication <em>on the map</em> as to which party is currently selected. Just like in the original Parties example, we solve this by creating a 50px x 50px transparent grey circular marker and making it concentric with the currently selected party&rsquo;s marker such that it forms a light halo around the selected party. The halo marker is purely a UI artefact that does not need to be saved on the server.</p>

<p><code>js
L.divIcon({
  iconSize: [50, 50], // set to 50px x 50px
  className: 'leaflet-animated-div-icon'
}
</code>
<code>css
.leaflet-animated-div-icon {
  border-radius: 50%;
  border: none;
  opacity: .2;
  background: black;
}
</code></p>

<h3>Animating the Halo Marker</h3>


<p>For a final flourish, we use the AnimatedMarker Leaflet plugin created by <a href=""></a> from OpenPlans to animate the marker as it moves about when a user selects different parties (rather than simply making it reappear at a different location). AnimatedMarker takes a Leaflet <code>polyline</code> object as the first argument to its  initialize function, and draws the marker at the beginning of the polyline. It then animates the marker along the polyline at a speed (in meters/ms) that&rsquo;s configurable via a second options argument.</p>

<p>We need to make a minor tweak to the plugin&rsquo;s source code to support our needs: The original AnimatedMarker does not allow setting of the animation polyline after the marker is initialized. As a result, it requires the complete animation path to be known before creating the marker. But we want to create the AnimatedMarker once and to then set the animation polyline dynamically as soon as a user selects a different marker. The next animation polyline would be a single segment from the AnimatedMarker&rsquo;s current location to the center of the next marker selected. To accomplish this, I&rsquo;ve had to reset the internal index (<code>this._i</code>) to 1 when a <code>polyline</code> is passed to the setLine method, making the method repeatedly reusable, rather than something that&rsquo;s called just once upon the marker&rsquo;s initialization. Until my pull request is merged, this modification is available at my fork on github.</p>

<p><a href="http://chicago-parties.meteor.com">Ta-da!</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Realtime Maps With Meteor and Leaflet - Part One]]></title>
    <link href="http://asynchrotron.com/blog/2013/12/27/realtime-maps-with-meteor-and-leaflet/"/>
    <updated>2013-12-27T20:51:10-06:00</updated>
    <id>http://asynchrotron.com/blog/2013/12/27/realtime-maps-with-meteor-and-leaflet</id>
    <content type="html"><![CDATA[<p><span class='caption-wrapper'><img class='caption' src='https://raw.github.com/meteor/meteor/devel/examples/parties/public/soma.png">https://raw.github.com/meteor/meteor/devel/examples/parties/public/soma.png</a>' width='350' height='350' title='this &lsquo;map&rsquo; is actually a static image'><span class='caption-text'>this &lsquo;map&rsquo; is actually a static image</span></span>
The <a href="https://www.meteor.com/examples/parties">Parties example</a> bundled with <a href="http://www.meteor.com">Meteor</a> is a nifty demonstration of the framework&rsquo;s core principles, but the application isn&rsquo;t nearly as useful as it could be because it uses a <a href="https://github.com/meteor/meteor/blob/devel/examples/parties/public/soma.png">500 x 500 pixel image of downtown San Francisco</a> as a faux map. This means that we cannot pan or zoom the &ldquo;map,&rdquo; nor can we initialize it to any other location or zoom level; when we double-click the image to create new parties, <a href="http://d3js.com">D3.js</a> is used to draw circles marking the position of the new parties in relation to the <em>image element in the browser window</em>, and not at geospatial coordinates.</p>

<p><span class='caption-wrapper left'><img class='caption' src='/images/custom/old-parties.png' width='350' height='350' title='a static image with circles drawn on it'><span class='caption-text'>a static image with circles drawn on it</span></span></p>

<p>I decided to update the example to use <a href="http://leafletjs.com/">Leaflet.js</a> to make a real map that looks and feels as close to the original example as possible. In particular, I wanted to preserve the color-coded circles -red for private, blue for public parties- labeled with the number of RSVPs, and the larger animated circle indicating which party is currently selected (with details about the selected party displayed in the sidebar). This is a useful pattern for displaying individual marker details without using a popup that occludes part of the map.</p>

<p>TLDR; End result: <a href="http://chicago-parties.meteor.com">http://chicago-parties.meteor.com</a> and <a href="https://github.com/pkaushik/parties">source code for the complete application</a>. You need to log in with a github account to create or RSVP to parties.</p>

<h3>Setting the Stage</h3>


<p>First off, we add the leaflet package to our project from the command line. Conveniently, leaflet is an officially supported Meteor package.
<code>
$ meteor add leaflet
leaflet: Leaflet.js, mobile-friendly interactive maps....
</code></p>

<p>Since we&rsquo;ll no longer be calculating relative coordinates to draw circles on a jpeg image, the base map does not need to be a fixed size. We can use Bootstrap&rsquo;s fluid classes to generate a <a href="http://getbootstrap.com/2.3.2/scaffolding.html#responsive">responsive page layout</a> and adjust the map&rsquo;s size as the browser is resized. This pattern is frequently used when creating responsive Leaflet maps, and not specific to Meteor.</p>

<p>``` html
<div class="container-fluid">
  <div class="row-fluid"></p>

<pre><code>&lt;div class="span4"&gt;
  {{&gt; details}}
  {{#if currentUser}}
  &lt;div class="pagination-centered"&gt;
    &lt;em&gt;&lt;small&gt;Double click the map to post a party!&lt;/small&gt;&lt;/em&gt;
  &lt;/div&gt;
  {{/if}}
&lt;/div&gt;
&lt;div class="span8"&gt;
    {{&gt; map}}
&lt;/div&gt;
</code></pre>

<p>  </div>
</div>
```</p>

<p><code>js
$(window).resize(function () {
  var h = $(window).height(), offsetTop = 90; // Calculate the top offset
  $mc = $('#map_canvas');
  $mc.css('height', (h - offsetTop));
}).resize();
</code></p>

<h3>Map Initialization</h3>


<p>Leaflet initialization code goes into the map template&rsquo;s <code>rendered()</code> callback. <a href="http://stamen.com/">Stamen Design</a>&rsquo;s <a href="http://maps.stamen.com/toner/#12/37.7706/-122.3782">toner themed map tiles</a> are a nice replacement for the black &amp; white map image in the original example. Disabling click and touch zoom onthe map lets us reserve those actions for users to create a new party, and increasing the map tiles' opacity improves the visibility of markers against the very dark toner theme.</p>

<p>``` js
map = L.map($(&lsquo;#map_canvas&rsquo;), {
  doubleClickZoom: false,
  touchZoom: false
}).setView(new L.LatLng(41.8781136, -87.66677956445312), 13);</p>

<p>L.tileLayer(&lsquo;<a href="http://">http://</a>{s}.tile.stamen.com/toner/{z}/{x}/{y}.png&rsquo;, {opacity: .5}).addTo(map);
```</p>

<p>Next we replace the map template&rsquo;s event handler from the original example with Leaflet&rsquo;s <code>"dblclick"</code> event handler which conveniently returns a Leaflet <code>LatLng</code> with its callback, which we promptly save as the Meteor Session variable <code>Session.createCoords</code>. Because Meteor Session variables are reactive, setting <code>Session.showCreateDialog</code> triggers the display of a dialog allowing the user to enter additional details about the new party. This mechanism is unchanged from the original example.</p>

<p>``` js
map.on(&ldquo;dblclick&rdquo;, function(e) {
  if (! Meteor.userId()) // must be logged in to create parties</p>

<pre><code>return;
</code></pre>

<p>  Session.set(&ldquo;createCoords&rdquo;, e.latlng);
  Session.set(&ldquo;showCreateDialog&rdquo;, true);
});
<code>
</code> html
<template name="page">
  {{#if showCreateDialog}}</p>

<pre><code>{{&gt; createDialog}}
</code></pre>

<p>  {{/if}}
  &hellip;
  &hellip;
</template>
```</p>

<h3>Creating and Saving a Party to the Database</h3>


<p>Clicking the create dialog&rsquo;s &lsquo;Save&rsquo; button makes a <code>Meteor.methods()</code> call that is virtually the same as in the original example except that the method now takes the <code>LatLng</code> that we just saved as <code>Session.createCoords</code>. When the new party has been successfully added to a server-side mongo collection called Parties, we can save the new party&rsquo;s <code>_id</code> to the <code>Session.selected</code> variable.</p>

<p>``` js
var title = template.find(&ldquo;.title&rdquo;).value;
var description = template.find(&ldquo;.description&rdquo;).value;
var public = ! template.find(&ldquo;.private&rdquo;).checked;
var latlng = Session.get(&ldquo;createCoords&rdquo;);</p>

<p>Meteor.call(&lsquo;createParty&rsquo;, {
  title: title,
  description: description,
  latlng: latlng,
  public: public
}, function (error, partyId) {
  if (! error) { //party was successfully added to the server&rsquo;s mongo collection</p>

<pre><code>Session.set("selected", partyId);
...
...
</code></pre>

<p>  }
});
```</p>

<h3>Adding Markers to the Map in Realtime</h3>


<p>So far, we&rsquo;ve saved a newly created party into a server-side mongo collection and Meteor, behind the scenes, has transmitted it back to a client-side minimongo collection with the same name (Parties). We can verify this by typing <code>Parties.findOne()</code> into the JavaScript console.</p>

<p>Let&rsquo;s now observe changes to a client-side query of the minimongo collection, and automatically draw a map marker whenever a new party is added. Since this only needs to be set up once, we can put the <code>cursor.observe()</code> code in the map template&rsquo;s <code>created()</code> callback. This replaces the D3 svg circle drawing code from the original example.</p>

<p>``` js
var map, markers = {};</p>

<p>Template.map.created = function() {
  Parties.find({}).observe({</p>

<pre><code>added: function(party) {
  var marker = new L.Marker(party.latlng, {
    _id: party._id,
    icon: createIcon(party)
  }).on('click', function(e) {
    Session.set("selected", e.target.options._id);
  });      
  map.addLayer(marker);
  markers[marker.options._id] = marker;
},
...
...
</code></pre>

<p>  });
}
<code>
In the</code>added()<code>callback, we create a new marker, add it to the map, and set up a click handler to store the associated party's</code><em>id<code>in another Meteor Session variable,</code>Session.selected<code>. We also store a reference to the marker in a locally scoped hash keyed by the associated party's</code></em>id``` to efficiently update / delete markers when party details change.</p>

<p>The <code>createIcon</code> function returns a lightweight <a href="http://leafletjs.com/reference.html#divicon"><code>DivIcon</code></a> that uses a simple <code>div</code> element instead of an image, and CSS <code>border-radius</code> to style the div as a circle of the appropriate color. The <code>attending()</code> helper method from the original example returns the number of Yes RSVPs. CSS <code>vertical-align</code> and <code>line-height</code> set to the height of the <code>div</code> when used in combination ensure the HTML text is vertically centered.</p>

<p>``` js
var createIcon = function(party) {
  var className = &lsquo;leaflet-div-icon &rsquo;;
  className += party.public ? &lsquo;public&rsquo; : &lsquo;private&rsquo;;
  return L.divIcon({</p>

<pre><code>iconSize: [30, 30], // set size to 30px x 30px
html: '&lt;b&gt;' + attending(party) + '&lt;/b&gt;',
className: className  
</code></pre>

<p>  });
}
<code>
</code> css
.leaflet-div-icon {
  border-radius: 50%;
  border: none;
  line-height: 30px;
  font-family: verdana;
  text-align: center;
  color: white;
  opacity: .8;
  vertical-align: middle;
}</p>

<p>.leaflet-div-icon.public {
  background: #49AFCD;
}</p>

<p>.leaflet-div-icon.private {
  background: #DA4F49;
}
<code>
At this point, we can create a bunch of parties and they all show up as markers with the appropriate color and label. When we click on a marker,</code>Session.selected``` is updated by the marker&rsquo;s click handler. Because Meteor Session variables are <a href="http://docs.meteor.com/#reactivity">reactive</a>, this automatically renders the details template in the sidebar.</p>

<p>But there&rsquo;s no visual indication <em>on the map</em> as to which party is currently selected &mdash; we just need to remember which marker we clicked on last! As it turns out, this usability issue is easy to fix and we&rsquo;ll see how in the next post.</p>

<p><a href="/blog/2013/12/28/realtime-maps-with-meteor-and-leaflet-part-2/">Part Two: Updating and deleting parties, and animating the selected party indicator&hellip;</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello Meteor!]]></title>
    <link href="http://asynchrotron.com/blog/2012/05/22/hello-meteor/"/>
    <updated>2012-05-22T15:22:00-05:00</updated>
    <id>http://asynchrotron.com/blog/2012/05/22/hello-meteor</id>
    <content type="html"><![CDATA[<p>Here are the <a href="https://speakerdeck.com/u/pkaushik/p/meteor">slides</a> from my <a href="http://www.meetup.com/js-chi/events/59833642">JS.Chi() talk on Meteor</a>. I will follow up with posts expanding on most of the slides in the presentation. This post, however, is for the benefit of all those who are feeling like they might be missing a step with frameworks like Backbone, Ember, (and now Meteor), et. al. It is an overview of the types of problems they&rsquo;re solving and includes recommendations for further reading.</p>

<script async class="speakerdeck-embed" data-id="4fbbc61f15a68f001f027e5a" data-ratio="1.2945638432364097" src="http://asynchrotron.com//speakerdeck.com/assets/embed.js"></script>




<br/>


<br/>




<h3>First a brief note about MVC</h3>


<p></p>

<p>The Model-View-Controller application architecture (MVC) is used in most modern applications to separate an application’s data from its business rules and user interface. Briefly, Models represent an application’s data and functions to access it. Views represent information presented to the user. Controllers represent intermediary resources required to generate Views. The MVC pattern isn&rsquo;t new (it can be traced back to Smalltalk), but it was popularized , along with the REST style of client-server API design, by server-side web frameworks such as Rails and Django.</p>

<h3>So what's all the fuss about JavaScript MVC frameworks (Backbone, Ember, et. al.)?</h3>


<p>If you think of the screens &ndash; or pages &ndash; in your application as different &ldquo;states&rdquo; in your application, server-side frameworks require a round trip back to the server when the user goes from one application state to another. This is fine for content-heavy apps or websites. Or if you&rsquo;re accessing the pages via an ethernet cable or 802.11. But when you move to high latency connections and along the continuum &mdash; and I believe it really is a continuum &mdash; from a web site to a web app, you can deliver a much better user experience if you avoid the server round trip for each state change, and instead switch from state to state on the client, within a single browser page load cycle.</p>

<p>This saves you all of the overhead of destroying and recreating the DOM tree, flushing browser context (JavaScript, CSS, etc.) on each new page load. You also are transmitting less data on the wire (or ether) since HTML is generated on the client, and only JSON passed over the network. Both of these factors (page refresh time and network traffic optimization) are significant when you consider the fact that more and more internet usage is taking place via mobiles and tablets.</p>

<p>You would still need a server to authenticate users and perform other privileged operations, and to store the &ldquo;official&rdquo; version of the data that different clients synchronize with, but instead of sending dynamically created HTML to the client (a la aforementioned server-side frameworks) the server would send as much data as needed (typically as JSON) to the client, and the client would create all of the different application states dynamically. The problem with this approach &mdash; and I&rsquo;ve been writing apps this way since 2008, without the benefit of any client side frameworks &mdash; is that they quickly turn into a mass of spaghetti code.</p>

<p>This is where the likes of Backbone, Ember, etc. come in. They are a re-imagination of the MVC application architecture for JavaScript application development in the client, where all (or nearly all) application states are handled in the client, in JavaScript. They provide a way to structure your JavaScript applications in a more organized MVC style.</p>

<p><a href="http://addyosmani.com/largescalejavascript/">Addy Osmani&rsquo;s articles</a>, and especially his <a href="http://addyosmani.github.com/backbone-fundamentals/">Backbone Fundamentals book</a> are a great place to start reading more about this. Although it&rsquo;s focused on one specific framework (Backbone), it has a good overview of MVC and how the pattern has moved from server side frameworks (like Rails, Django) to the client side (Backbone, et. al.).</p>

<p>I also wholeheartedly recommend his <a href="http://addyosmani.com/scalable-javascript-videos/">recent talks on providing structure to JavaScript apps</a>.</p>

<p>And this is a useful <a href="http://codebrief.com/2012/01/the-top-10-javascript-mvc-frameworks-reviewed/">comparison of various front-end frameworks</a>, although the conclusions should be taken with a grain of salt (it&rsquo;s one persons&rsquo;s perspective, and things are not quite as quantifiable as the article suggests).</p>

<p>So, all of these are client side frameworks, which solve the problems of a) separating client side code into MVC, and b) optionally, allowing views to &ldquo;observe&rdquo; client side models, so that views get updated automatically as the data in the models is updated or as new data arrives from the server.</p>

<p>This gets you pretty far, but all of these applications have something else in common which the previously mentioned MVC frameworks don&rsquo;t address: They need to send data back to the server and know if data has changed on the server. In other words, they need to synchronize client side models with the server side models.</p>

<h3>Enter Meteor.</h3>


<p></p>

<p><a href="http://meteor.com">Meteor</a> is a full stack framework for end-to-end JavaScript applications. The beauty of coding it all in JavaScript is that you can easily implement the observer pattern (views watching for changes to the models) all the way to the server side. Meteor apps can subscribe to models (or subsets of models) on the server, and meteor takes care of all of the plumbing. This really is the bleeding edge of JS today.</p>

<p>For more on the problems Meteor solves, read the <a href="http://docs.meteor.com/">meteor docs</a> from the intro section through to as many of the detailed concepts you&rsquo;re interested in. Or come to <a href="http://www.meetup.com/js-chi/events/59833642">my talk at JS.Chi()</a> and we will work through it together.</p>

<p>Have fun!</p>
]]></content>
  </entry>
  
</feed>
