<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Leaflet | Pallavi Anderson]]></title>
  <link href="http://asynchrotron.com/blog/categories/leaflet/atom.xml" rel="self"/>
  <link href="http://asynchrotron.com/"/>
  <updated>2013-12-28T17:30:04-06:00</updated>
  <id>http://asynchrotron.com/</id>
  <author>
    <name><![CDATA[Pallavi Anderson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Realtime Maps With Meteor and Leaflet - Part 1]]></title>
    <link href="http://asynchrotron.com/blog/2013/12/27/realtime-maps-with-meteor-and-leaflet/"/>
    <updated>2013-12-27T20:51:10-06:00</updated>
    <id>http://asynchrotron.com/blog/2013/12/27/realtime-maps-with-meteor-and-leaflet</id>
    <content type="html"><![CDATA[<p><span class='caption-wrapper'><img class='caption' src='https://raw.github.com/meteor/meteor/devel/examples/parties/public/soma.png">https://raw.github.com/meteor/meteor/devel/examples/parties/public/soma.png</a>' width='350' height='350' title='the map is actually a static image'><span class='caption-text'>the map is actually a static image</span></span>
The <a href="https://www.meteor.com/examples/parties">Parties example</a> bundled with <a href="http://www.meteor.com">Meteor</a> is a nifty demonstration of the framework&rsquo;s core principles. It also shows how we might implement fine-grained data access control to limit who can see and edit specific items in a collection &ndash; in this case which users are allowed to RSVP to parties. But the application isn&rsquo;t nearly as useful as it could be because it displays a <a href="https://github.com/meteor/meteor/blob/devel/examples/parties/public/soma.png">500 x 500 pixel image of downtown San Francisco</a> as the faux map. This means that we cannot pan or zoom the &ldquo;map,&rdquo; nor can we initialize it to any other location or zoom level, and when we double click the image to create a party, D3 draws a circle to mark the position of the click in relation to the <em>image element in the browser window</em>, and not at geospatial coordinates.</p>

<p>I decided to refactor the example to use <a href="http://leafletjs.com/">Leaflet.js</a> to make a real map that looks and feels as close to the original as possible. The color-coded circle markers (pink for private, blue for public parties) labeled with the number of RSVPs are nice and lightweight, and I like how the larger animated circle is used to indicate which party is currently selected, with details about the party shown in the sidebar. It&rsquo;s a useful pattern for showing details about an individual map marker without using the standard popup approach which occludes part of the map.</p>

<p>TLDR; End result: <a href="http://chicago-parties.meteor.com">http://chicago-parties.meteor.com</a> and <a href="https://github.com/pkaushik/parties">source code for the complete application</a>. You need a github account to log in, to create or RSVP to parties.</p>

<h3>Setting the Stage</h3>


<p>First off, since we&rsquo;ll no longer be calculating relative x and y coordinates to position circles on a jpeg image, the map does not need to be of a fixed size. We modify the page template to use Bootstrap&rsquo;s fluid classes to generate a responsive layout, and include the following boilerplate to adjust the map&rsquo;s size as the window is resized. This pattern is standard practice when creating responsive Leaflet maps; not specific to Meteor.</p>

<p>``` html
<div class="container-fluid">
  <div class="row-fluid"></p>

<pre><code>&lt;div class="span4"&gt;
  {{&gt; details}}
  {{#if currentUser}}
  &lt;div class="pagination-centered"&gt;
    &lt;em&gt;&lt;small&gt;Double click the map to post a party!&lt;/small&gt;&lt;/em&gt;
  &lt;/div&gt;
  {{/if}}
&lt;/div&gt;
&lt;div class="span8"&gt;
    {{&gt; map}}
&lt;/div&gt;
</code></pre>

<p>  </div>
</div>
```</p>

<p><code>js
$(window).resize(function () {
  var h = $(window).height(), offsetTop = 90; // Calculate the top offset
  $mc = $('#map_canvas');
  $mc.css('height', (h - offsetTop));
}).resize();
</code></p>

<h3>Map Initialization</h3>


<p>Map initialization code goes into the template&rsquo;s <code>rendered()</code> callback. Stamen&rsquo;s <a href="http://maps.stamen.com/toner/#12/37.7706/-122.3782">toner themed map tiles</a> are a nice replacement for the black &amp; white map image. Disabling click and touch zoom lets us reserve those actions for creating a new party, and adjusting the base map&rsquo;s opacity improves the visibility of markers against the very dark toner theme.</p>

<p>``` js
map = L.map($(&lsquo;#map_canvas&rsquo;), {
  doubleClickZoom: false,
  touchZoom: false
}).setView(new L.LatLng(41.8781136, -87.66677956445312), 13);</p>

<p>L.tileLayer(&lsquo;<a href="http://">http://</a>{s}.tile.stamen.com/toner/{z}/{x}/{y}.png&rsquo;, {opacity: .5}).addTo(map);
```</p>

<p>Next we replace the map template&rsquo;s event handler from the original example with Leaflet&rsquo;s <code>"dblclick"</code> event handler which conveniently returns a Leaflet <code>LatLng</code> as the argument to its callback.</p>

<p>``` js
map.on(&ldquo;dblclick&rdquo;, function(e) {
  if (! Meteor.userId()) // must be logged in to create parties</p>

<pre><code>return;
</code></pre>

<p>  Session.set(&ldquo;createCoords&rdquo;, e.latlng);
  &hellip;
  &hellip;
});
```</p>

<h3>Creating and Saving a Party to the Database</h3>


<p>The code to create a new party using a <code>Meteor.methods()</code> call is virtually the same as in the original example except that the method now takes the <code>LatLng</code> that we saved as <code>Session.createCoords</code>. When the new party has been created and successfully saved in a server-side mongo collection, we get a successful callback and save the new party&rsquo;s <code>_id</code> to the <code>Session.selected</code> variable. This ensures that the most recently created party is always selected.</p>

<p>``` js
var title = template.find(&ldquo;.title&rdquo;).value;
var description = template.find(&ldquo;.description&rdquo;).value;
var public = ! template.find(&ldquo;.private&rdquo;).checked;
var latlng = Session.get(&ldquo;createCoords&rdquo;);</p>

<p>Meteor.call(&lsquo;createParty&rsquo;, {
  title: title,
  description: description,
  latlng: latlng,
  public: public
}, function (error, partyId) {
  if (! error) {</p>

<pre><code>Session.set("selected", partyId);
...
...
</code></pre>

<p>  }
});
```</p>

<h3>Adding, Removing, and Updating Markers on the Map in Realtime</h3>


<p>So far, we&rsquo;ve saved a newly created party into the server-side Parties mongo collection and behind the scenes, Meteor has transmitted it back to the client-side monomongo collection with the same name. We can verify this by typing <code>Parties.findOne()</code> into the JavaScript console.</p>

<p>Let&rsquo;s now observe changes to the client&rsquo;s monomongo collection and automatically draw a map marker every time a new party is added to the collection. Since this only needs to be set up once, we can put the following code in the map template&rsquo;s <code>created()</code> callback. This replaces the D3 circle drawing code from the original example.</p>

<p>``` js
var map, markers = {};</p>

<p>Template.map.created = function() {
  Parties.find({}).observe({</p>

<pre><code>added: function(party) {
  var marker = new L.Marker(party.latlng, {
    _id: party._id,
    icon: createIcon(party)
  }).on('click', function(e) {
    Session.set("selected", e.target.options._id);
  });      
  map.addLayer(marker);
  markers[marker.options._id] = marker;
},
...
...
changed: function(party) {
  var marker = markers[party._id];
  if (marker) marker.setIcon(createIcon(party));
},
removed: function(party) {
  var marker = markers[party._id];
  if (map.hasLayer(marker)) {
    map.removeLayer(marker);
    delete markers[party._id];
  }
}
</code></pre>

<p>  });
}
<code>
The</code>added()<code>callback stores a reference to the new marker in a hash keyed by</code>Party._id<code>. This is useful since we need to efficiently update / delete markers when the RSVP count changes or a party is deleted. The</code>createIcon<code>function uses the new lightweight [</code>DivIcon<code>](http://leafletjs.com/reference.html#divicon) that uses a simple</code>div<code>element instead of an image and CSS</code>border-radius<code>to style the div as a circle of the appropriate color. The</code>attending()<code>from the original example returns the number of Yes RSVPs. CSS</code>line-height<code>(set tot he height of the</code>div<code>) and</code>vertical-align``` used in combination ensure the HTML text is vertically centered.</p>

<p>``` js
var createIcon = function(party) {
  var className = &lsquo;leaflet-div-icon &rsquo;;
  className += party.public ? &lsquo;public&rsquo; : &lsquo;private&rsquo;;
  return L.divIcon({</p>

<pre><code>iconSize: [30, 30], // set size to 30px x 30px
html: '&lt;b&gt;' + attending(party) + '&lt;/b&gt;',
className: className  
</code></pre>

<p>  });
}
<code>
</code> css
.leaflet-div-icon {</p>

<pre><code>border-radius: 50%;
border: none;
line-height: 30px; 
font-family: verdana;
text-align: center;
color: white;
opacity: .8;
vertical-align: middle;
</code></pre>

<p>}</p>

<p>.leaflet-div-icon.public { background: #49AFCD; }</p>

<p>.leaflet-div-icon.private { background: #DA4F49; }
```</p>

<p><em>Next: Updating and deleting parties, and animating the selected party indicator&hellip;</em></p>
]]></content>
  </entry>
  
</feed>
